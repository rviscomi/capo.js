---
title: Custom Adapters
description: Learn how to create and test custom adapters for capo.js.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

This guide explains how to create custom adapters for capo.js and validate them using the built-in test utilities.

## Why Custom Adapters?

Custom adapters allow you to use capo.js with different HTML parsers or AST formats, such as:
- JSX/React elements
- Vue template AST
- Svelte component AST  
- Custom XML parsers
- Server-side rendering frameworks

## Creating a Custom Adapter

### Step 1: Extend the AdapterInterface

```javascript
import { AdapterInterface } from '@rviscomi/capo.js/adapters';

export class MyCustomAdapter extends AdapterInterface {
  // Implement all 11 required methods
  
  isElement(node) {
    // Return true if node is a valid element for your parser
    return node && node.type === 'YourElementType';
  }
  
  getTagName(node) {
    // Return lowercase tag name
    if (!node) return '';
    return node.tagName?.toLowerCase() || '';
  }
  
  getAttribute(node, name) {
    // Get attribute value (case-insensitive)
    if (!node || !node.attributes) return null;
    const attr = node.attributes.find(a => 
      a.name.toLowerCase() === name.toLowerCase()
    );
    return attr ? attr.value : null;
  }
  
  hasAttribute(node, name) {
    return this.getAttribute(node, name) !== null;
  }
  
  getAttributeNames(node) {
    if (!node || !node.attributes) return [];
    return node.attributes.map(a => a.name);
  }
  
  getTextContent(node) {
    if (!node) return '';
    return node.textContent || '';
  }
  
  getChildren(node) {
    if (!node || !node.children) return [];
    return node.children.filter(child => this.isElement(child));
  }
  
  getParent(node) {
    return node && node.parent;
  }
  
  getSiblings(node) {
    const parent = this.getParent(node);
    if (!parent) return [];
    return this.getChildren(parent).filter(c => c !== node);
  }
  
  getLocation(node) {
    // Return source location if available, otherwise null
    if (!node || !node.loc) return null;
    return {
      start: { line: node.loc.start.line, column: node.loc.start.column },
      end: { line: node.loc.end.line, column: node.loc.end.column }
    };
  }
  
  stringify(node) {
    // Return string representation of the element
    if (!node) return '';
    const attrs = this.getAttributeNames(node)
      .map(name => `${name}="${this.getAttribute(node, name)}"`)
      .join(' ');
    return `<${this.getTagName(node)}${attrs ? ' ' + attrs : ''}>`;
  }
}
```

### Step 2: Register Your Adapter

```javascript
import { AdapterFactory } from '@rviscomi/capo.js/adapters';
import { MyCustomAdapter } from './my-custom-adapter.js';

// Register the adapter
AdapterFactory.register('my-parser', MyCustomAdapter);

// Now you can use it
const adapter = AdapterFactory.create('my-parser');

// Or let the factory auto-detect it by updating the detect() method
```

## Validating Your Adapter

capo.js provides **three levels of validation** for custom adapters:

### Level 1: Automatic Validation (Registration Time)

The simplest validation happens automatically when you register your adapter:

```javascript
import { AdapterFactory } from '@rviscomi/capo.js/adapters';
import { MyCustomAdapter } from './my-custom-adapter.js';

// This will throw an error if your adapter is invalid
AdapterFactory.register('my-parser', MyCustomAdapter);
// ✅ Validates that all 11 required methods exist
```

**What it checks:**
- Adapter class is a valid constructor
- Adapter can be instantiated
- All 11 required methods are implemented

**When to use:** Quick validation during development.

### Level 2: Programmatic Validation

Use the `validateAdapter()` function for explicit validation:

```javascript
import { validateAdapter } from '@rviscomi/capo.js/adapters';
import { MyCustomAdapter } from './my-custom-adapter.js';

const adapter = new MyCustomAdapter();

try {
  validateAdapter(adapter);
  console.log('✅ Adapter is valid!');
} catch (error) {
  console.error('❌ Adapter validation failed:', error.message);
}
```

**What it checks:**
- All 11 required methods exist
- Each method is a function

**When to use:** Integration tests, CI/CD pipelines.

### Level 3: Full Test Suite

Run the comprehensive test suite to validate behavior:

```javascript
import { describe } from 'node:test';
import { runAdapterTestSuite, testAdapterCompliance } from '@rviscomi/capo.js/adapters/test-suite';
import { MyCustomAdapter } from './my-custom-adapter.js';
import { parseHtml } from './my-parser.js';  // Your parser

describe('MyCustomAdapter', () => {
  // Full test suite - tests all methods with edge cases
  runAdapterTestSuite(MyCustomAdapter, {
    createElement: (htmlString) => {
      // Your logic to create a node from HTML
      return parseHtml(htmlString);
    },
    supportsLocation: true  // true if getLocation() works
  });
  
  // OR: Quick compliance check only
  testAdapterCompliance(MyCustomAdapter);
});
```

### Note on Parent Pointers

Some adapters, like those for ESLint, require parent pointers on nodes to support `getParent()` and `getSiblings()`. If your parser doesn't provide these pointers by default (like `@html-eslint/parser`), you must shim them in your test setup.

For ESLint adapters, it's recommended to use ESLint's `RuleTester` in your tests to provide a realistic environment where parent pointers are automatically injected:

```javascript
import { RuleTester } from 'eslint';
import * as htmlParser from 'your-html-parser'; // e.g., @html-eslint/parser

const ruleTester = new RuleTester({
  languageOptions: { parser: htmlParser }
});

runAdapterTestSuite(MyAdapter, {
  createElement: (html) => {
    let capturedNode = null;
    ruleTester.run('capture', {
      create: () => ({
        Tag: (node) => { if (!capturedNode) capturedNode = node; }
      })
    }, {
      valid: [html]
    });
    return capturedNode;
  }
});
```

**What it tests:**
- All 11 methods with various inputs
- Edge cases (null, undefined, empty strings)
- Expected return types
- Case-insensitivity
- 39 individual test cases

**When to use:** Comprehensive validation before release.

## Full Example: JSX Adapter

<Tabs>
  <TabItem label="Adapter">
```javascript
// jsx-adapter.js
import { AdapterInterface } from '@rviscomi/capo.js/adapters';

export class JsxAdapter extends AdapterInterface {
  isElement(node) {
    return node && node.type === 'JSXElement';
  }
  
  getTagName(node) {
    if (!this.isElement(node)) return '';
    return node.openingElement.name.name.toLowerCase();
  }
  
  getAttribute(node, name) {
    if (!this.isElement(node)) return null;
    const nameLower = name.toLowerCase();
    const attr = node.openingElement.attributes.find(a => 
      a.name && a.name.name.toLowerCase() === nameLower
    );
    if (!attr || !attr.value) return null;
    return attr.value.value || null;
  }
  
  hasAttribute(node, name) {
    return this.getAttribute(node, name) !== null;
  }
  
  getAttributeNames(node) {
    if (!this.isElement(node)) return [];
    return node.openingElement.attributes
      .filter(a => a.name)
      .map(a => a.name.name);
  }
  
  getTextContent(node) {
    if (!this.isElement(node)) return '';
    // JSX text is in children, but can also be in expressions (e.g. for style/script)
    return node.children
      .map(c => {
        if (c.type === 'JSXText') return c.value;
        if (c.type === 'JSXExpressionContainer') {
          if (c.expression.type === 'TemplateLiteral') {
            return c.expression.quasis[0].value.cooked;
          }
          if (c.expression.type === 'StringLiteral') {
            return c.expression.value;
          }
        }
        return '';
      })
      .join('');
  }
  
  getChildren(node) {
    if (!this.isElement(node)) return [];
    return node.children.filter(c => c.type === 'JSXElement');
  }
  
  getLocation(node) {
    if (!this.isElement(node) || !node.loc) return null;
    return {
      start: { line: node.loc.start.line, column: node.loc.start.column },
      end: { line: node.loc.end.line, column: node.loc.end.column }
    };
  }
  
  getParent(node) {
    return (node && node.parent) || null;
  }

  getSiblings(node) {
    const parent = this.getParent(node);
    if (!parent) return [];
    return this.getChildren(parent).filter(c => c !== node);
  }
  
  stringify(node) {
    if (!this.isElement(node)) return '';
    const tag = this.getTagName(node);
    const attrs = this.getAttributeNames(node)
      .map(name => `${name}="${this.getAttribute(node, name)}"`)
      .join(' ');
    return `<${tag}${attrs ? ' ' + attrs : ''}>`;
  }
}
```
  </TabItem>
  <TabItem label="Test">
```javascript
// jsx-adapter.test.js
import { describe } from 'node:test';
import { runAdapterTestSuite } from '@rviscomi/capo.js/adapters/test-suite';
import { JsxAdapter } from './jsx-adapter.js';
import { parse } from '@babel/parser';

describe('JsxAdapter', () => {
  runAdapterTestSuite(JsxAdapter, {
    createElement: (htmlString) => {
      // Convert HTML to JSX by closing self-closing tags
      const selfClosingTags = ['meta', 'link', 'base', 'br', 'img', 'input', 'hr'];
      let jsxString = htmlString;
      selfClosingTags.forEach(tag => {
        const regex = new RegExp(`<(${tag}(?:\\s+[^>]*)?)>`, 'gi');
        jsxString = jsxString.replace(regex, '<$1 />');
      });

      // Handle style/script content by wrapping in template literals
      jsxString = jsxString.replace(/<(style|script)([^>]*)>([\s\S]*?)<\/\1>/gi, '<$1$2>{`$3`}</$1>');

      const code = `const el = (<>${jsxString}</>);`;
      const ast = parse(code, {
        plugins: ['jsx'],
        sourceType: 'module'
      });
      
      // Extract JSX element from AST (inside fragment)
      const root = ast.program.body[0].declarations[0].init.children[0];

      // Add parent pointers for tests that need them
      const traverse = (node, parent = null) => {
        if (!node) return;
        node.parent = parent;
        if (node.children) {
          node.children.forEach(child => traverse(child, node));
        }
      };
      traverse(root);
      return root;
    },
    supportsLocation: true
  });
});
```
  </TabItem>
  <TabItem label="Usage">
```javascript
// Usage
import { AdapterFactory } from '@rviscomi/capo.js/adapters';
import { JsxAdapter } from './jsx-adapter.js';

// Register the adapter
AdapterFactory.register('jsx', JsxAdapter);

// Use it with capo.js
import { getHeadWeights } from '@rviscomi/capo.js';

const adapter = AdapterFactory.create('jsx');
const weights = getHeadWeights(jsxHeadElement, adapter);
```
  </TabItem>
</Tabs>

## Best Practices

1. **Always extend AdapterInterface** - Don't implement from scratch
2. **Test thoroughly** - Run the full test suite before releasing
3. **Handle null gracefully** - All methods should handle null/undefined inputs
4. **Return consistent types** - Follow the exact return types in the interface
5. **Be case-insensitive** - Attribute names should be case-insensitive
6. **Handle Parent Pointers** - If your parser doesn't provide `node.parent`, you may need to shim it or use a traversal helper, especially for tests.
7. **Document your adapter** - Explain what parser/format it supports

## API Reference

### runAdapterTestSuite(AdapterClass, options)

Runs comprehensive tests on a custom adapter.

**Parameters:**
- `AdapterClass` (Function) - The adapter constructor to test
- `options` (Object)
  - `createElement` (Function) - Function that creates test nodes from HTML strings
  - `supportsLocation` (boolean, optional) - Whether adapter supports `getLocation()`. Default: `false`

**Example:**
```javascript
runAdapterTestSuite(MyAdapter, {
  createElement: (html) => parseHtml(html),
  supportsLocation: true
});
```

### testAdapterCompliance(AdapterClass)

Quick compliance check that verifies all required methods exist.

**Parameters:**
- `AdapterClass` (Function) - The adapter constructor to test

**Example:**
```javascript
testAdapterCompliance(MyAdapter);
```

### validateAdapter(adapter)

Programmatically validates an adapter instance.

**Parameters:**
- `adapter` (Object) - Adapter instance to validate

**Throws:** Error if validation fails

**Example:**
```javascript
const adapter = new MyAdapter();
validateAdapter(adapter);  // throws if invalid
```

## Troubleshooting

**"Adapter missing required method: X"**
- Ensure your adapter implements all 11 required methods
- Check for typos in method names
- Verify methods are functions, not properties

**"Cannot detect adapter for node"**
- Your node type isn't recognized by the factory
- Register your adapter explicitly: `AdapterFactory.create('your-name')`
- Or update `AdapterFactory.detect()` to recognize your node type

**Tests failing with "createElement is required"**
- You must provide a `createElement` function in test options
- This function should convert HTML strings to your parser's node format

## Support

For questions or issues with custom adapters:
- [GitHub Issues](https://github.com/rviscomi/capo.js/issues)
- [Discussions](https://github.com/rviscomi/capo.js/discussions)
